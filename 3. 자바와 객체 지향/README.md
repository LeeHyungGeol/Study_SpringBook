# 3장 자바와 객체 지향

## "우리가 주변에서 사물을 인지하는 방식대로 프로그래밍할 수 있지 않겠는가"하는 것이 바로 객체 지향의 출발이다.
---
## 클래스(Class)와 객체(Object)
---

* **클래스(Class)** : 같은 속성과 기능을 가진 객체를 총칭하는 개념 / 사물을 **분류** / **개념**
* **객체(Object)** : 세상에 존재하는 모든 고유한 사물 / **실체** 

클래스와 객체를 간단히 구분하는 법 

* 생물인 경우 : "나이가 어떻게 되나요?"
* 무생물인 경우 : "제조일자가 어떻게 되나요?"
  
클래스와 객체를 작명할 때도 ***클래스***는 **분류**로, ***객체 참조 변수명***은 **유일무이한 사물**의 이름으로 작명해야 한다.
* Mouse jerry = new Mouse(); - ***객체 참조 변수명을 잘 작성한 예시***
    * Mouse의 나이는? - Mouse는 **분류**의 개념이기 때문에 해당 질문에 답할 수 없기 때문에 Class이다.
    
    * jerry의 나이는? - jerry는 **유일무이한 객체**이므로 해당 질문에 답할 수 있기 때문에 객체스럽게 작명한 것이다.

* 조류 bird = new 조류(); - ***객체 참조 변수명을 잘못 작성한 예시***
    * 조류의 나이는? - 조류는 **분류**의 개념이기 때문에 해당 질문에 답할 수 없기 때문에 Class이다.
    
    * bird의 나이는? - bird 또한 **분류**의 개념이기 때문에 해당 질문에 답할 수 없기 때문에 Class이다.

---
## 객체 지향의 4대 특성 
---
* **캡슐화(Encapsulation)** : 정보 은닉(Information Hiding)
* **상속(Inheritance)** : 재사용과 확장(extends)
* **추상화(Abstraction)** : 모델링(modeling)
* **다형성(Polymorphism)** : 사용 편의성
---
## 추상화 : 모델링
---
ex)

<img src="https://user-images.githubusercontent.com/56071088/107866834-45dbc280-6eb8-11eb-8ba8-b2b1b8829824.png"  width="400" height="300">

### 추상화란 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합하는 것

### 추상화 = 모델링 = Java의 Class 키워드

세상에 존재하는 유일무이한 객체를 특성(속성 + 기능)에 따라 분류해 보니 객체를 통칭할 수 있는 집합적 개념, 즉 클래스(분류)가 나오게 된다.

* 객체는 유일무이(unique)한 사물이다.
* 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념이다.

이때 내가 구체적인 사물들(객체)을 관심있는 분야(Context)에 대한 **공통된 특성(속성(Property)+ 기능(Method))** 만을 찾아내어 재조합한다. 

객체 지향에서 추상화의 결과는 Class이다.

[ **클래스 객체_참조_변수 = new 클래스();** ]

<img src="https://user-images.githubusercontent.com/56071088/107867095-ff3b9780-6eba-11eb-865b-8e8380cd6187.png"  width="450" height="400">

Mouse mickey = new Mouse();

### 클래스 객체_참조_변수 = new 클래스();

* 클래스의 인스턴스. 즉, 객체를 생성해서 그 객체의 주소값(포인터)를 객체 참조 변수에 할당
* 객체(Object) = 클래스의 인스턴스(Instance)
* **new 클래스();** -> **클래스의 인스턴스**를 하나 만들어서 **힙(Heap)영역**에 배치한다.
* **멤버 변수(속성)** 은 **공유 변수**의 성격을 가지고 있기 때문에 ***자동으로 초기화***된다. 공유 변수를 딱히 누가 초기화해야 한다고 규정할 수 없기 때문이다.

---
### 혼용해서 사용하는 단어
* 클래스 멤버 = static 멤버 = 정적 멤버
* 객체 멤버 = 인스턴스 멤버 = 오브젝트 멤버
* 함수(Function) = 메서드(Method)
* 변수 공간 = 메모리 공간
---
## 상속 : 재사용과 확장 : extends
---
### 객체 지향에서 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다.
* 분류도
* 상위 클래스 - 하위 클래스 / 슈퍼 클래스 - 서브 클래스
* **하위 클래스는 상위 클래스다.** 
    * 객체 지행 설계 5원칙 중 **LSP(리스코프 치환 원칙)**
* **하위 클래스 is a kind of 상위 클래스**
    * ex) 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류다.
    * ex) 펭귄 is a kind of 동물 -> 펭귄은 동물의 한 분류다.
  
* 객체 지향에서의 상속은 상위 클래스의 특성을 ***재사용***하는 것이다.
* 객체 지향에서의 상속은 상위 클래스의 특성을 ***확장***하는 것이다.
* 객체 지향의 상속은 ***is a kind of 관계***를 만족한다.

* JAVA에서 다중 상속은 2개 이상의 상위 클래스가 있을 때, 하위 클래스는 어떠한 속성을 재사용 및 확장하는 것이 모호하기에 **다중 상속을 포기했다.**
  
### 상속과 인터페이스

* 인터페이스: 구현 클래스 ***is able to*** 인터페이스 -> 구현 클래스는 인터페이스할 수 있다.
* **인터페이스**는 ***be able to, "무엇을 할 수 있는"이라는 형태***로 만드는 것이 좋다.
* 상위 클래스는 하위 클래스에게 특성(속성과 메서드)를 상속해준다.
* 인터페이스는 클래스가 '무엇을 할 수 있다'라는 기능을 **구현하도록 강제하게 된다.**
  
    * **상위 클래스가 물려줄 특성이 많을수록 좋다.** -> ***LSP(리스코프 치환 원칙)***
  
    * **인터페이스에 메서드가 적을수록 좋다.** -> ***ISP(인터페이스 분할 원칙)***

[ **상속과 데이터 저장 영역** ]

<img src="https://user-images.githubusercontent.com/56071088/107868112-acff7400-6ec4-11eb-81cc-2f68ab4210d4.PNG"  width="450" height="350">

Penguin pororo = new Penguin();
Animal pingu = new Penguin();

* 데이터 저장 영역의 힙(Heap)영역에 하위 클래스인 Penguin 클래스의 인스턴스가 생성될 때, 상위 클래스인 Animal 클래스의 인스턴스도 함께 생성된다.

* 인스턴스가 생성 될 때, 모든 클래스의 최상의 클래스인 Object 클래스의 인스턴스도 함께 생성된다.

* Animal인 pingu가 habitat과 show_habitat()에 접근할 수 없다. 하고 싶다면 **형변환(Casting)** 을 이용하여 초기화 해주어야 한다.

---
## 다형성 : 사용편의성
---

* **오버라이딩(Overriding)** : 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 ***재정의*** 
  *  마치 인공위성에서 오토바이에 올라탄 사람을 볼 때, 오토바이는 보이지 않고 오토바이에 오버라이딩(올라타기)된 맨 위의 존재만 보이는 경우이다.
* **오버로딩(Overloading)** : 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 ***중복 정의***
    * 인공위성에서 트럭에 적재된 운송물을 볼 때, 오버로딩(적재하기)된 경우는 옆으로 적대된 모든 적재물이 다 보인다.

[ **다형성과 데이터 저장 영역**]

<img src="https://user-images.githubusercontent.com/56071088/107868462-dec60a00-6ec7-11eb-9f18-84368cace438.png"  width="450" height="400">

* **상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다.**

### 다형성의 본질

<img src="https://user-images.githubusercontent.com/56071088/107868577-cb676e80-6ec8-11eb-958c-aeb5c6730fac.PNG"  width="500" height="300">

### 역할과 구현을 분리

* 자바 언어의 다형성을 활용
* 역할 = 인터페이스
* 구현 = 인터페이스를 구현한 클래스, 구현 객체
* 객체를 설계할 때 ***역할과 구현을 명확히 분리!!!***
* 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

*  인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 **유연**하게 **변경**할 수 있다.
* 다형성의 본질을 이해하려면 **협력**이라는 객체사이의 관계에서 시작해야함
* ***클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.***

---
## 캡슐화 : 정보 은닉
---
### 정보 은닉(Inforamtion Hiding)은 접근 제어자를 통한 접근 제한을 의미

### 접근 제어자 : private, [default], protected, public

* private : 본인만 접근 가능
* [default] : **같은 패키지** 내의 클래스에서 접근 가능
* protected : **상속 / 같은 패키지** 내의 클래스에서 접근 가능
* public : 모두가 접근 가능


**정적 멤버**인 경우 **클래스명.정적멤버** 형식으로 접근하자
* ex) 사람.인구수 / 펭귄.다리개수 -> O
* ex2) 홍길동.인구수 /  뽀로로.다리개수 -> X

**메모리 접근 방식**에 있어서도 클래스명.정적멤버 형식이 더 유리하다.







